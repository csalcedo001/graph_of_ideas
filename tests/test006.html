<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.0.16/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>Konva Connect Objects demo</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f0f0;
      }
    </style>
  </head>

  <body>
    <div id="container"></div>
    <script>
      var width = window.innerWidth;
      var height = window.innerHeight;

      var stage = new Konva.Stage({
        container: 'container',
        width: width,
        height: height
      });

      var layer = new Konva.Layer();
      stage.add(layer);

		const Circle = class {
			constructor(x, y, r) {
				// Object unique ID
				this.id = objectCount;
				objectCount++;

				// Add object to global object mapping
				objectMap[this.id] = this;

				// Object positioning and color
				this.move(x, y);
				this.r = r;
				this.color = "#FFFFFF";

				// Text to be displayed in object
				this.text = "";

				// Object of indices
				// TODO : Replace by array, since object cant be sorted?
				this.outNeighbors = {};
				// TODO : Replace by actual auto call in outNeighbors?
				this.selfNeighbor = false; // For multigraphs, represent by number
			}

			draw() {
				// Draw the circle
				ctx.fillStyle = this.color;
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
				ctx.stroke();
				ctx.fill();

				// Print text inside circle
				ctx.fillStyle = "black";
				ctx.font = "10px Arial";
				ctx.fillText(this.text, this.x, this.y);
			}

			move(x, y) {
				this.x = x;
				this.y = y;
			}

			// Test whether the object contains point (x, y)
			contains(x, y) {
				return Math.sqrt(
					(x - this.x) * (x - this.x) +
					(y - this.y) * (y - this.y)
				) <= this.r;
			}

			// Update color
			paint(color) {
				this.color = color;
			}

			// Update text
			say(text) {
				this.text = text;
			}

			connect(obj) {
				if (obj.id == this.id) {
					this.selfNeighbor = true;
				} else {
					this.outNeighbors[id] = obj;
				}
			}
		}

      // function to generate a list of "targets" (circles)
      function generateTargets() {
        var number = 10;
        var result = [];
        while (result.length < number) {
          result.push({
            id: 'target-' + result.length,
            x: (240 * result.length) % stage.width(),
            y: (70 * result.length) % stage.height(),
			text: new Konva.Text({
      		  text: 'Some text here',
      		  x: node.x(),
      		  y: node.y(),
      		  fontSize: 20,
      		  draggable: true,
      		  width: node.radius()
      		})
          });
        }
        return result;
      }

      var targets = generateTargets();

      // function to generate arrows between targets
      function generateConnectors() {
        var number = 10;
        var result = [];
        while (result.length < number) {
          var from = 'target-' + Math.floor(Math.random() * targets.length);
          var to = 'target-' + Math.floor(Math.random() * targets.length);
          if (from === to) {
            continue;
          }
          result.push({
            id: 'connector-' + result.length,
            from: from,
            to: to
          });
        }
        return result;
      }

      function getConnectorPoints(from, to) {
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        let angle = Math.atan2(-dy, dx);

        const radius = 50;

        return [
          from.x + -radius * Math.cos(angle + Math.PI),
          from.y + radius * Math.sin(angle + Math.PI),
          to.x + -radius * Math.cos(angle),
          to.y + radius * Math.sin(angle)
        ];
      }

      var connectors = generateConnectors();

      // update all objects on the canvas from the state of the app
      function updateObjects() {
        targets.forEach(target => {
          var node = layer.findOne('#' + target.id);
          node.x(target.x);
          node.y(target.y);

        });
        connectors.forEach(connect => {
          var line = layer.findOne('#' + connect.id);
          var fromNode = layer.findOne('#' + connect.from);
          var toNode = layer.findOne('#' + connect.to);

          const points = getConnectorPoints(
            fromNode.position(),
            toNode.position()
          );
          line.points(points);
        });
        layer.batchDraw();
      }

      // generate nodes for the app
      connectors.forEach(connect => {
        var line = new Konva.Arrow({
          stroke: 'black',
          id: connect.id,
          fill: 'black'
        });
        layer.add(line);
      });

      targets.forEach(target => {
        var node = new Konva.Circle({
          id: target.id,
          fill: 'green',
          radius: 20 + Math.random() * 20,
          draggable: true
        });
        layer.add(node);

        node.on('dragmove', () => {
          // mutate the state
          target.x = node.x();
          target.y = node.y();

          // update nodes from the new state
          updateObjects();
        });

      var textNode = new Konva.Text({
        text: 'Some text here',
        x: node.x(),
        y: node.y(),
        fontSize: 20,
        draggable: true,
        width: node.radius()
      });

        node.on('dragmove', () => {
          // mutate the state
          target.x = node.x();
          target.y = node.y();
		  textNode.x = node.x();
		  textNode.y = node.y();

          // update nodes from the new state
          updateObjects();
        });

      layer.add(textNode);

      var tr = new Konva.Transformer({
        node: textNode,
        enabledAnchors: ['middle-left', 'middle-right', 'top-center', 'bottom-center'],
        // set minimum width of text
        boundBoxFunc: function(oldBox, newBox) {
          newBox.width = Math.max(30, newBox.width);
          newBox.height = Math.max(30, newBox.height);
          return newBox;
        }
      });

      textNode.on('transform', function() {
        // reset scale, so only with is changing by transformer
        textNode.setAttrs({
          width: textNode.width() * textNode.scaleX(),
          height: textNode.height() * textNode.scaleY(),
          scaleX: 1,
		  scaleY: 1
        });
      });

      layer.add(tr);

      layer.draw();

	  textNode.on('click', () => {
        textNode.show();
        tr.show();
        layer.draw();

        function removeTextarea() {
          textarea.parentNode.removeChild(textarea);
          window.removeEventListener('click', handleOutsideClick);
          textNode.show();
          tr.show();
          tr.forceUpdate();
          layer.draw();
        }

       function handleOutsideClick(e) {
         if (e.target !== textarea) {
           textNode.text(textarea.value);
           removeTextarea();
         }
       }
	  });

      textNode.on('dblclick', () => {
        // hide text node and transformer:
        textNode.hide();
        tr.hide();
        layer.draw();

        // create textarea over canvas with absolute position
        // first we need to find position for textarea
        // how to find it?

        // at first lets find position of text node relative to the stage:
        var textPosition = textNode.absolutePosition();

        // then lets find position of stage container on the page:
        var stageBox = stage.container().getBoundingClientRect();

        // so position of textarea will be the sum of positions above:
        var areaPosition = {
          x: stageBox.left + textPosition.x,
          y: stageBox.top + textPosition.y
        };

        // create textarea and style it
        var textarea = document.createElement('textarea');
        document.body.appendChild(textarea);

        // apply many styles to match text on canvas as close as possible
        // remember that text rendering on canvas and on the textarea can be different
        // and sometimes it is hard to make it 100% the same. But we will try...
        textarea.value = textNode.text();
        textarea.style.position = 'absolute';
        textarea.style.top = areaPosition.y + 'px';
        textarea.style.left = areaPosition.x + 'px';
        textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
        textarea.style.height =
          textNode.height() - textNode.padding() * 2 + 5 + 'px';
        textarea.style.fontSize = textNode.fontSize() + 'px';
        textarea.style.border = 'none';
        textarea.style.padding = '0px';
        textarea.style.margin = '0px';
        textarea.style.overflow = 'hidden';
        textarea.style.background = 'none';
        textarea.style.outline = 'none';
        textarea.style.resize = 'none';
        textarea.style.lineHeight = textNode.lineHeight();
        textarea.style.fontFamily = textNode.fontFamily();
        textarea.style.transformOrigin = 'left top';
        textarea.style.textAlign = textNode.align();
        textarea.style.color = textNode.fill();
        rotation = textNode.rotation();
        var transform = '';
        if (rotation) {
          transform += 'rotateZ(' + rotation + 'deg)';
        }

        var px = 0;
        // also we need to slightly move textarea on firefox
        // because it jumps a bit
        var isFirefox =
          navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        if (isFirefox) {
          px += 2 + Math.round(textNode.fontSize() / 20);
        }
        transform += 'translateY(-' + px + 'px)';

        textarea.style.transform = transform;

        // reset height
        textarea.style.height = 'auto';
        // after browsers resized it we can set actual value
        textarea.style.height = textarea.scrollHeight + 3 + 'px';

        textarea.focus();

        function removeTextarea() {
          textarea.parentNode.removeChild(textarea);
          window.removeEventListener('click', handleOutsideClick);
          textNode.show();
          tr.show();
          tr.forceUpdate();
          layer.draw();
        }

        function setTextareaWidth(newWidth) {
          if (!newWidth) {
            // set width for placeholder
            newWidth = textNode.placeholder.length * textNode.fontSize();
          }
          // some extra fixes on different browsers
          var isSafari = /^((?!chrome|android).)*safari/i.test(
            navigator.userAgent
          );
          var isFirefox =
            navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          if (isSafari || isFirefox) {
            newWidth = Math.ceil(newWidth);
          }

          var isEdge =
            document.documentMode || /Edge/.test(navigator.userAgent);
          if (isEdge) {
            newWidth += 1;
          }
          textarea.style.width = newWidth + 'px';
        }

        textarea.addEventListener('keydown', function(e) {
          // hide on enter
          // but don't hide on shift + enter
          if (e.keyCode === 13 && !e.shiftKey) {
            textNode.text(textarea.value);
            removeTextarea();
          }
          // on esc do not set value back to node
          if (e.keyCode === 27) {
            removeTextarea();
          }
        });

        textarea.addEventListener('keydown', function(e) {
          scale = textNode.getAbsoluteScale().x;
          setTextareaWidth(textNode.width() * scale);
          textarea.style.height = 'auto';
          textarea.style.height =
            textarea.scrollHeight + textNode.fontSize() + 'px';
        });

        function handleOutsideClick(e) {
          if (e.target !== textarea) {
            textNode.text(textarea.value);
            removeTextarea();
          }
        }
        setTimeout(() => {
          window.addEventListener('click', handleOutsideClick);
        });
      });
      });

      updateObjects();
    </script>
  </body>
</html>
