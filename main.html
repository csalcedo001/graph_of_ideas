<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.0.16/konva.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <meta charset="utf-8" />
    <title>Konva Connect Objects demo</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f0f0;
      }
    </style>
  </head>

  <body>
    <p id="text"></p>
    <div id="container"></div>
    <script>
      var width = window.innerWidth;
      var height = window.innerHeight;

      var stage = new Konva.Stage({
      id: "stage",
        container: 'container',
        width: width,
        height: height,
        draggable: true
      });

      var container = stage.container();
      container.tabIndex = 1;
      container.focus();

      var layer = new Konva.Layer({
        id: "layer"
      });

      stage.add(layer);


      var nodes = {};
      var edges = {};

      function createNode(id, x, y, text="") {
          var newNode = new Konva.Group({
            id: "node-".concat(id),
            x: x - stage.x(),
            y: y - stage.y(),
            draggable: true
          })

          var newCircle = new Konva.Circle({
            id: "circle-".concat(id),
            radius: 100,
            x: 0,
            y: 0,
            fill: 'green',
          });

          var newText = new Konva.Text({
            id: "text-".concat(id),
            x: 0,
            y: 0,
            text: text
          });

          newText.x(-newText.width() / 2);
          newText.y(-newText.height() / 2);

          var nodeStruct = {
            id: id,
            group: newNode,
            circle: newCircle,
            text: newText,
            edges: []
          };

          nodes[newNode.id()] = nodeStruct;

          newNode.add(newCircle);
          newNode.add(newText);

          newNode.on("dragmove", () => {
            nodes[newNode.id()].edges.forEach(id => {
              var edge = edges[id];
              position = edgeTargetPosition(nodes[edge.source.id()], nodes[edge.target.id()]);

              edge.edge.points([edge.source.x(), edge.source.y(), position.x, position.y]);
            });

            stage.draw();
          });

          layer.add(newNode);
          layer.batchDraw();

          return nodeStruct;
      }

      function createEdge(id, source, target) {
        id = "arrow-".concat(id);
        if (newEdge === null) {
          var position = edgeTargetPosition(nodes[source.id()], nodes[target.id()]);
          newEdge = new Konva.Arrow({
            id: id,
            points: [source.x(), source.y(), position.x, position.y],
            stroke: "black"
          });
          layer.add(newEdge);
          newEdge.moveToBottom();
        } else {
          newEdge.id(id);
        }

        edgeStruct = {
          id: id,
          edge: newEdge,
          source: source,
          target: target
        };
        edges[id] = edgeStruct;

        nodes[source.id()].edges.push(id);
        nodes[target.id()].edges.push(id);
        newEdge = null;

        layer.batchDraw();

        return edgeStruct;
      }

      $.getJSON("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/graph", function(data) {
        data.nodes.forEach(nodeStruct => {
          createNode(nodeStruct.id, nodeStruct.x, nodeStruct.y, nodeStruct.text);
        });
        data.edges.forEach(edgeStruct => {
          createEdge(edgeNextID(), nodes["node-".concat(edgeStruct[0])].group, nodes["node-".concat(edgeStruct[1])].group)
        });
      });

      // async function getGraph() {
      //   let response = await fetch("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/graph");
      //
      //   if (response.ok) {
      //     let json = await response.json();
      //   } else {
      //     window.alert("HTTP-Error: " + response.status);
      //   }
      // }

      async function postGraph(data) {
        let response = await fetch("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/save", {
          method: 'POST',
          body: JSON.stringify(data)
        })
        .then(response => {
          return response.json();
        })
        .then(response => {
          if (error in response) {
            window.alert(responde.message);
          } else {
            window.alert("Saved!");
          }
        })
        .catch(function(err) {
          window.alert("ERROR: Couldn't save work.");
          window.alert(err);
        });
      }

      var nodeID = 100;
      function nodeNextID() {
        return (nodeID++).toString();
      }

      var edgeID = 0;
      function edgeNextID() {
        return (edgeID++).toString();
      }

      function edgeTargetPosition(source, target) {
        var xVector = target.group.x() - source.group.x();
        var yVector = target.group.y() - source.group.y();
        var h = Math.sqrt(Math.pow(xVector, 2) + Math.pow(yVector, 2));

        return {
          x: target.group.x() - target.circle.radius() * xVector / h,
          y: target.group.y() - target.circle.radius() * yVector / h
        };
      }

      container.addEventListener("keydown", function(e) {
        if (window.event.metaKey && e.which == 83) {
          postGraph({
            nodes: Object.values(nodes).map(function(node) {
              return {
                id: node.id,
                x: node.group.x(),
                y: node.group.y(),
                text: node.text.text()
              };
            }),
            edges: Object.values(edges).map(function(edge) {
              return [
                nodes[edge.source.id()].id,
                nodes[edge.target.id()].id
              ];
            })
          });
        }
      });

      stage.on("dblclick", function(e) {
        if (currentTarget.id() == "stage") {
          var position = stage.getPointerPosition();
          var node = createNode(nodeNextID(), position.x, position.y);
          new Node("999", 20, 20);
        } else if (currentTarget.id()[0] == "n") {
          var node = nodes[currentTarget.id()];
          // From this point until the end of the if block, code has been
          // taken from https://konvajs.org/docs/sandbox/Editable_Text.html
          var textNode = node.text;

          node.text.hide();
          layer.batchDraw();

          // create textarea over canvas with absolute position
          // first we need to find position for textarea
          // how to find it?

          // at first lets find position of text node relative to the stage:
          var textPosition = textNode.absolutePosition();

          // then lets find position of stage container on the page:
          var stageBox = stage.container().getBoundingClientRect();

          // so position of textarea will be the sum of positions above:
          var areaPosition = {
            x: stageBox.left + textPosition.x,
            y: stageBox.top + textPosition.y
          };

          // create textarea and style it
          var textarea = document.createElement('textarea');
          document.body.appendChild(textarea);

          // apply many styles to match text on canvas as close as possible
          // remember that text rendering on canvas and on the textarea can be different
          // and sometimes it is hard to make it 100% the same. But we will try...
          textarea.value = textNode.text();
          textarea.style.position = 'absolute';
          textarea.style.top = areaPosition.y + 'px';
          textarea.style.left = areaPosition.x + 'px';
          textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
          textarea.style.height =
            textNode.height() - textNode.padding() * 2 + 5 + 'px';
          textarea.style.fontSize = textNode.fontSize() + 'px';
          textarea.style.border = 'none';
          textarea.style.padding = '0px';
          textarea.style.margin = '0px';
          textarea.style.overflow = 'hidden';
          textarea.style.background = 'none';
          textarea.style.outline = 'none';
          textarea.style.resize = 'none';
          textarea.style.lineHeight = textNode.lineHeight();
          textarea.style.fontFamily = textNode.fontFamily();
          textarea.style.transformOrigin = 'left top';
          textarea.style.textAlign = textNode.align();
          textarea.style.color = textNode.fill();
          rotation = textNode.rotation();
          var transform = '';
          if (rotation) {
            transform += 'rotateZ(' + rotation + 'deg)';
          }

          var px = 0;
          // also we need to slightly move textarea on firefox
          // because it jumps a bit
          var isFirefox =
            navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          if (isFirefox) {
            px += 2 + Math.round(textNode.fontSize() / 20);
          }
          transform += 'translateY(-' + px + 'px)';

          textarea.style.transform = transform;

          // reset height
          textarea.style.height = 'auto';
          // after browsers resized it we can set actual value
          textarea.style.height = textarea.scrollHeight + 3 + 'px';

          textarea.focus();

          function removeTextarea() {
            textarea.parentNode.removeChild(textarea);
            window.removeEventListener('click', handleOutsideClick);
            textNode.show();
            layer.draw();
          }

          function setTextareaWidth(newWidth) {
            if (!newWidth) {
              // set width for placeholder
              newWidth = textNode.placeholder.length * textNode.fontSize();
            }
            // some extra fixes on different browsers
            var isSafari = /^((?!chrome|android).)*safari/i.test(
              navigator.userAgent
            );
            var isFirefox =
              navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isSafari || isFirefox) {
              newWidth = Math.ceil(newWidth);
            }

            var isEdge =
              document.documentMode || /Edge/.test(navigator.userAgent);
            if (isEdge) {
              newWidth += 1;
            }
            textarea.style.width = newWidth + 'px';
          }

          textarea.addEventListener('keydown', function(e) {
            // hide on enter
            // but don't hide on shift + enter
            if (e.keyCode === 13 && !e.shiftKey) {
              textNode.text(textarea.value);
              removeTextarea();
            }
            // on esc do not set value back to node
            if (e.keyCode === 27) {
              removeTextarea();
            }
          });

          textarea.addEventListener('keydown', function(e) {
            scale = textNode.getAbsoluteScale().x;
            setTextareaWidth(textNode.width() * scale);
            textarea.style.height = 'auto';
            textarea.style.height =
              textarea.scrollHeight + textNode.fontSize() + 'px';
          });

          function handleOutsideClick(e) {
            if (e.target !== textarea) {
              textNode.text(textarea.value);
              removeTextarea();
            }
          }
          setTimeout(() => {
            window.addEventListener('click', handleOutsideClick);
          });
        }
      });


      var mouseX, mouseY;
      var newEdgeAnimation = new Konva.Animation(function(frame){}),
          newEdge = null,
          newEdgeSource;
      var currentTarget = stage;

      stage.on("mousemove", function(e) {
        var position = stage.getPointerPosition();
        mouseX = position.x - stage.x();
        mouseY = position.y - stage.y();

        currentTarget = e.target.id()[0] == "c" || e.target.id()[0] == "t" ?
          e.target.getParent() :
          stage;

        document.getElementById('text').textContent = currentTarget.id();
      });


      stage.on("mousedown", function(e) {
        if (currentTarget.id()[0] == "n" && window.event.metaKey) {
          if (newEdgeAnimation.isRunning()) {
            newEdgeAnimation.stop();
            newEdge.destroy();
          }

          newEdgeSource = currentTarget;

          newEdge = new Konva.Arrow({
            id: "arrow-new",
            stroke: 'black'
          });

          newEdgeAnimation = new Konva.Animation(function (frame) {
            var targetX, targetY;

            if (currentTarget.id()[0] == "n" && currentTarget != newEdgeSource) {
              var position = edgeTargetPosition(nodes[newEdgeSource.id()], nodes[currentTarget.id()]);

              targetX = position.x;
              targetY = position.y;
            } else {
              targetX = mouseX;
              targetY = mouseY;
            }

            newEdge.points([newEdgeSource.x(), newEdgeSource.y(), targetX, targetY]);
          }, layer);

          layer.add(newEdge);
          newEdge.moveToBottom();
          newEdgeSource.draggable(false);

          newEdgeAnimation.start();
        }
      });

      stage.on("mouseup", function(e) {
        if (newEdgeAnimation.isRunning()) {
          newEdgeAnimation.stop();
          newEdgeSource.draggable(true);

          if (currentTarget.id()[0] == "n") {
            createEdge(edgeNextID(), newEdgeSource, currentTarget);
          } else {
            newEdge.destroy();
          }

          layer.batchDraw();
        }
      });

      // var text = new Konva.Text({
      //   text: 'Hola',
      //   x: 100,
      //   y: 100
      // })

      // layer.add(text);

      // var tr = new Konva.Transformer({
      //   node: circle,
      //   enabledAnchors: ['top-center', 'bottom-center', 'middle-left', 'middle-right'],
      //   visible: false,
      //   // set minimum width of text
      //   boundBoxFunc: function(oldBox, newBox) {
      //     newBox.width = Math.max(30, newBox.width);
      //     newBox.height = Math.max(30, newBox.height);
      //     return newBox;
      //   }
      // });

      // layer.add(tr);

      // circle.on('dragmove', function() {
      //   text.x(circle.x());
      //   text.y(circle.y());
      // });

      // circle.on('click', function() {
      //   tr.visible(true);
      // });

      // circle.on('transform', function() {
      //   circle.setAttrs({
      //     width: circle.width() * circle.scaleX(),
      //     height: circle.height() * circle.scaleY(),
      //     scaleX: 1,
      //     scaleY: 1
      //   });

      //   text.x(circle.x());
      //   text.y(circle.y());
      //   text.rotation(circle.rotation());
      // });

      // layer.batchDraw();
    </script>
  </body>
</html>
