<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.0.16/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>Konva Connect Objects demo</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f0f0;
      }
    </style>
  </head>

  <body>
    <p id="text"></p>
    <div id="container"></div>
    <script>
      var width = window.innerWidth;
      var height = window.innerHeight;

      var stage = new Konva.Stage({
      id: "stage",
        container: 'container',
        width: width,
        height: height,
        draggable: true
      });

      // Let stage capture keyboard events
      var container = stage.container();
      container.tabIndex = 1;
      container.focus();

      // Layer for arrows, drawn below layer of nodes
      var edgeLayer = new Konva.Layer({
        id: "Layer-arrows"
      });
      var nodeLayer = new Konva.Layer({
        id: "Layer-nodes"
      });

      stage.add(edgeLayer);
      stage.add(nodeLayer);


      // Objects that map ids of nodes and edges to their objects
      var nodes = {};
      var edges = [];

      class Graph {
        constructor() {
          this.nodes = {};
          this.edges = [];
        }
      };

      class Node extends Konva.Group {
        constructor(obj) {
          /**
            Arguments:
            obj -- Initialization object for parent class, circle and text.
          **/
          // TODO: Add nodeLayer as attribute of Node class
          // TODO: Define Node.draw() & Node.batchDraw()

          var id = nodeNextID();

          // Set constant parameters
          obj.id = id;
          obj.draggable = true;
          obj.x = obj.x - stage.x();
          obj.y = obj.y - stage.y();

          super(obj);

          // Create text object
          this.text_ = new Konva.Text({
            id: "text-".concat(this.id()),
            x: 0,
            y: 0,
            text: obj.text
          });

          // Put text to middle of circle
          this.text_.x(-this.text_.width() / 2);
          this.text_.y(-this.text_.height() / 2);

          // Create circle object
          this.circle_ = new Konva.Circle({
            id: "circle-".concat(this.id()),
            x: 0,
            y: 0,
            radius: 100,
            fill: "green"
          });

          this.edges_ = [];

          // Re-draw edges when dragged
          this.on("dragmove", () => {
            this.edges_.forEach(edge => {
              var position = edgeTargetPosition(edge.source_, edge.target_);

              edge.points([edge.source_.x(), edge.source_.y(), position.x, position.y]);
            });

            edgeLayer.draw();
          });

          // Re-draw edges when transformed
          this.on("transform", () => {
            this.edges_.forEach(edge => {
              var position = edgeTargetPosition(edge.source_, edge.target_);

              edge.points([edge.source_.x(), edge.source_.y(), position.x, position.y]);
            });

            edgeLayer.draw();
          });

          // Add circle and text to node, and node to the node layer.
          this.add(this.circle_);
          this.add(this.text_);
          nodeLayer.add(this);

          nodeLayer.batchDraw();

          // Assign node pointer to its id in nodes object
          nodes[this.id()] = this;
        }
        radius(radius) {
          /**
            Getter and Setter of node radius.

            Arguments:
            radius -- New radius to set. If undefined, method is getter.

            Returns:
            If radius is undefined, returns radius of circle. If not, returns
            Node object with updated radius.
          **/
          if (radius === undefined || radius === null) {
            return this.circle_.radius();
          }
          else {
            this.circle_.radius(radius);

            return this;
          }
        }
        text(text) {
          /**
            Getter and Setter of node text.

            Arguments:
            text -- New text to set. If undefined, method is getter.

            Returns:
            If text is undefined, returns text of node. If not, returns
            Node object with updated text.
          **/

          if (text === undefined || text === null) {
            return this.text_.text();
          }
          else {
            this.text_.text(text);

            return this;
          }
        }
        connect(edge) {
          /**
            Connects node with an edge.

            Arguments:
            edge -- Edge object to connect with node.
          **/

          this.edges_.push(edge);
        }
        destroy() {
          /**
            Destroy node, circle, text and neighbor edges.
          **/

          // Destroy edges
          this.edges_.forEach(edge => {
            edge.destroy(edge.source_ == this ? edge.target_ : edge.source_);
          });

          // Remove node from object of nodes
          delete nodes[this.id()];

          // Destroy remaining objects
          this.circle_.destroy();
          this.text_.destroy();

          super.destroy();
        }
        // TODO: disconnect(edge)
      };


      class Edge extends Konva.Line {
        constructor(obj) {
          /**
            Arguments:
            obj -- Initialization object for parent class and arrow.
          **/

          var id = edgeNextID();

          // Set constant parameters

          obj.id = "edge-".concat(id);
          obj.strokeWidth = 18
          obj.opacity = 0;
          obj.stroke = "#69F",

          super(obj);

          // Define and connect source and target nodes
          this.source_ = obj.source;
          this.target_ = obj.target;

          this.source_.connect(this);
          this.target_.connect(this);

          // Find tagrget position for arrow
          var position = edgeTargetPosition(this.source_, this.target_);

          super.points([this.source_.x(), this.source_.y(), position.x, position.y]);

          // Create arrow object
          if ("arrow" in obj) {
            this.arrow_ = obj.arrow;

            this.arrow_.id("arrow-".concat(id));
          }
          else {
            this.arrow_ = new Konva.Arrow({
              id: "arrow-".concat(id),
              points: super.points(),
              strokeWidth: 4,
              stroke: "black"
            });

            // Add arrow object to arrow layer
            edgeLayer.add(this.arrow_);

            // Hide arrow behind touch area
            this.arrow_.moveToBottom();
          }

          // Add edge object to arrow layer
          edgeLayer.add(this);

          edgeLayer.draw();

          // Assign edge pointer to its id in nodes object
          edges.push(this);
        }
        destroy(target) {
          /**
            Destroy node, circle, text and neighbor edges.

            Arguments:
            target -- Node from which edge must be deleted. If undefined,
                      destroy from both nodes.
          **/

          var index;

          // Remove edge from edge lists of nodes
          if (target != this.target_) {
            index = this.source_.edges_.indexOf(this);
            this.source_.edges_.splice(index, 1);
          }
          if (target != this.source_) {
            index = this.target_.edges_.indexOf(this);
            this.target_.edges_.splice(index, 1);
          }

          // Remove edge from object of edges
          index = edges.indexOf(this);
          delete edges.splice(index, 1);

          // Destroy objects
          this.arrow_.destroy();

          super.destroy();
        }
        points(points) {
          /**
            Getter and Setter of edge points.

            Arguments:
            points -- New points to set. If undefined, method is getter.

            Returns:
            If points is undefined, returns current edge points. If not, returns
            Edge object with updated points.
          **/

          if (points === undefined || points === null) {
            this.arrow_.points();
            return super.points();
          }
          else {
            this.arrow_.points(points);
            super.points(points);

            return this;
          }

        }
      };

      // Mapping from node id's in server to assigned id's in session
      var nodeMapping = {};

      // TODO: Create Loader class get(graph), post(graph)
      async function getGraph() {
        /**
          Get graph nodes and edges.
        **/

        let response = await fetch("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/graph");

        if (response.ok) {
          // Get json if valid response
          let data = await response.json();

          var maxX, maxY, minX, minY;

          maxX = minX = data.nodes[0].x;
          maxY = minY = data.nodes[0].y;

          // Map each node in server with new id of session
          data.nodes.forEach(nodeStruct => {
            var node = new Node({
              x: nodeStruct.x,
              y: nodeStruct.y,
              text: nodeStruct.text,
              scaleX: nodeStruct.scaleX,
              scaleY: nodeStruct.scaleY,
              rotation: nodeStruct.rotation
            });

            nodeMapping[nodeStruct.id] = node.id();

            if (nodeStruct.x > maxX) {
              maxX = nodeStruct.x
            }
            if (nodeStruct.y > maxY) {
              maxY = nodeStruct.y
            }
            if (nodeStruct.x < minX) {
              minX = nodeStruct.x
            }
            if (nodeStruct.y < minY) {
              minY = nodeStruct.y
            }
          });

          // Create new edge with mapped ids
          data.edges.forEach(edgeStruct => {
            new Edge({
              source: nodes[nodeMapping[edgeStruct[0]]],
              target: nodes[nodeMapping[edgeStruct[1]]]
            });
          });

          // Find scale and position that shows every node in screen
          var offset = 400;
          var diffX = maxX - minX + offset,
              diffY = maxY - minY + offset;

          var scale = stage.height() / stage.width() < diffY / diffX
                      ? stage.height() / diffY
                      : stage.width() / diffX;

          stage.position({
            x: (offset / 2 - minX) * scale,
            y: (offset / 2 - minY) * scale
          });

          stage.scale({
            x: scale,
            y: scale
          });

          stage.draw();
        } else {
          // Error message
          window.alert("HTTP-Error: " + response.status);
        }
      }
      async function postGraph(data) {
        /**
          Post updated graph nodes and edges.

          Arguments:
          data -- Object that holds nodes and edges keys.
            nodes -- List of objects of attributes id, x, y and text.
            edges -- List of lists, pirs of source and target id's respectively.
        **/

        let response = await fetch("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/save", {
          method: 'POST',
          body: JSON.stringify(data)
        })
        .then(response => {
          return response.json();
        })
        .then(json => {
          if ("error" in json) {
            // Invalid data object format
            window.alert(json.message);
          }
          else {
            window.alert("Saved!");
          }
        })
        .catch(function(err) {
          // Unable to fetch
          window.alert("ERROR: Couldn't save work.");
          window.alert(err);
        });
      }

      getGraph();

      // TODO: If multithreading is available, this function should be atomic
      var nodeID = 0;
      function nodeNextID() {
        /**
          Get id of next node.
        **/

        return (nodeID++).toString();
      }

      var edgeID = 0;
      function edgeNextID() {
        /**
          Get id of next edge.
        **/

        return (edgeID++).toString();
      }

      function edgeTargetPosition(source, target) {
        /**
          Find point of arrow head given the source and target nodes.

          Arguments:
          source -- Node from which the arrow is drawn.
          target -- Node where the arrow points.

          Returns:
          -- Object of attributes x and y.
            x -- Number of x coordinate of arrow head.
            y -- Number of y coordinate of arrow head.
        **/

        // Move center of plane to target
        var px = source.x() - target.x();
        var py = source.y() - target.y();

        // Convert rotation angle to radians
        var rotation = -target.rotation() * Math.PI / 180;
        var pxtmp = px;

        // Rotate plane
        px = pxtmp * Math.cos(rotation) - py * Math.sin(rotation);
        py = pxtmp * Math.sin(rotation) + py * Math.cos(rotation);

        // Rescale plane
        px /= target.scaleX();
        py /= target.scaleY();

        // Find point in which circumference and line from source to target touch
        var h = Math.sqrt(Math.pow(px, 2) + Math.pow(py, 2));

        px *= target.radius() / h,
        py *= target.radius() / h

        // Undo rescale
        px *= target.scaleX();
        py *= target.scaleY();

        // Undo rotation
        rotation = -rotation;
        pxtmp = px;

        px = pxtmp * Math.cos(rotation) - py * Math.sin(rotation);
        py = pxtmp * Math.sin(rotation) + py * Math.cos(rotation);

        // Return plane to original position
        return {
          x: px + target.x(),
          y: py + target.y()
        };
      }

      container.addEventListener("keydown", function(e) {
        // Ctrl + S: Save graph
        if (window.event.ctrlKey && e.which == 83) {
          postGraph({
            nodes: Object.values(nodes).map(function(node) {
              return {
                id: node.id(),
                x: node.x(),
                y: node.y(),
                text: node.text(),
                scaleX: node.scaleX(),
                scaleY: node.scaleY(),
                rotation: node.rotation()
              };
            }),
            edges: edges.map(function(edge) {
              return [
                edge.source_.id(),
                edge.target_.id()
              ];
            })
          });
        }
        // Return: Delete selected object
        if (e.which == 8 && selectedObject != stage) {
          selectedObject.destroy();
          selectionTransformer.visible(false);
          stage.draw();
        }
      });

      stage.on("dblclick", function(e) {
        // Double click stage: Create node
        if (touchedObject.id() == "stage") {
          var position = stage.getPointerPosition();

          new Node({
            x: mouseX + stage.position().x,
            y: mouseY + stage.position().y,
            text: ""
          });
        }
        // Double click node: Text edition
        else if (!isNaN(touchedObject.id()[0])) {
          // From this point until the end of the if block, code has been
          // taken from https://konvajs.org/docs/sandbox/Editable_Text.html
          var textNode = touchedObject.text_;

          textNode.hide();
          nodeLayer.batchDraw();

          // create textarea over canvas with absolute position
          // first we need to find position for textarea
          // how to find it?

          // at first lets find position of text node relative to the stage:
          var textPosition = textNode.absolutePosition();

          // then lets find position of stage container on the page:
          var stageBox = stage.container().getBoundingClientRect();

          // so position of textarea will be the sum of positions above:
          var areaPosition = {
            x: stageBox.left + textPosition.x,
            y: stageBox.top + textPosition.y
          };

          // create textarea and style it
          var textarea = document.createElement('textarea');
          document.body.appendChild(textarea);

          // apply many styles to match text on canvas as close as possible
          // remember that text rendering on canvas and on the textarea can be different
          // and sometimes it is hard to make it 100% the same. But we will try...
          textarea.value = textNode.text();
          textarea.style.position = 'absolute';
          textarea.style.top = areaPosition.y + 'px';
          textarea.style.left = areaPosition.x + 'px';
          textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
          textarea.style.height =
            textNode.height() - textNode.padding() * 2 + 5 + 'px';
          textarea.style.fontSize = textNode.fontSize() + 'px';
          textarea.style.border = 'none';
          textarea.style.padding = '0px';
          textarea.style.margin = '0px';
          textarea.style.overflow = 'hidden';
          textarea.style.background = 'none';
          textarea.style.outline = 'none';
          textarea.style.resize = 'none';
          textarea.style.lineHeight = textNode.lineHeight();
          textarea.style.fontFamily = textNode.fontFamily();
          textarea.style.transformOrigin = 'left top';
          textarea.style.textAlign = textNode.align();
          textarea.style.color = textNode.fill();
          rotation = textNode.rotation();
          var transform = '';
          if (rotation) {
            transform += 'rotateZ(' + rotation + 'deg)';
          }

          var px = 0;
          // also we need to slightly move textarea on firefox
          // because it jumps a bit
          var isFirefox =
            navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          if (isFirefox) {
            px += 2 + Math.round(textNode.fontSize() / 20);
          }
          transform += 'translateY(-' + px + 'px)';

          textarea.style.transform = transform;

          // reset height
          textarea.style.height = 'auto';
          // after browsers resized it we can set actual value
          textarea.style.height = textarea.scrollHeight + 3 + 'px';

          textarea.focus();

          function removeTextarea() {
            textarea.parentNode.removeChild(textarea);
            window.removeEventListener('click', handleOutsideClick);
            textNode.show();
            nodeLayer.draw();
          }

          function setTextareaWidth(newWidth) {
            if (!newWidth) {
              // set width for placeholder
              newWidth = textNode.placeholder.length * textNode.fontSize();
            }
            // some extra fixes on different browsers
            var isSafari = /^((?!chrome|android).)*safari/i.test(
              navigator.userAgent
            );
            var isFirefox =
              navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isSafari || isFirefox) {
              newWidth = Math.ceil(newWidth);
            }

            var isEdge =
              document.documentMode || /Edge/.test(navigator.userAgent);
            if (isEdge) {
              newWidth += 1;
            }
            textarea.style.width = newWidth + 'px';
          }

          textarea.addEventListener('keydown', function(e) {
            // hide on enter
            // but don't hide on shift + enter
            if (e.keyCode === 13 && !e.shiftKey) {
              textNode.text(textarea.value);
              removeTextarea();
            }
            // on esc do not set value back to node
            if (e.keyCode === 27) {
              removeTextarea();
            }
          });

          textarea.addEventListener('keydown', function(e) {
            scale = textNode.getAbsoluteScale().x;
            setTextareaWidth(textNode.width() * scale);
            textarea.style.height = 'auto';
            textarea.style.height =
              textarea.scrollHeight + textNode.fontSize() + 'px';
          });

          function handleOutsideClick(e) {
            if (e.target !== textarea) {
              textNode.text(textarea.value);
              removeTextarea();
            }
          }
          setTimeout(() => {
            window.addEventListener('click', handleOutsideClick);
          });
        }
      });


      // Mouse position
      var mouseX, mouseY;

      // Create animation that sets arrow position to mouse position
      var newEdgeAnimation = new Konva.Animation(function (frame) {
        var targetX, targetY;

        if (!isNaN(touchedObject.id()[0]) && touchedObject != newEdgeSource) {
          // Assign arrow head position to node border

          var position = edgeTargetPosition(newEdgeSource, touchedObject);

          targetX = position.x;
          targetY = position.y;
        } else {
          // Assign arrow head position to mouse

          targetX = mouseX;
          targetY = mouseY;
        };
        newEdge.points([newEdgeSource.x(), newEdgeSource.y(), targetX, targetY]);
      }, nodeLayer);

      var newEdge,
          newEdgeSource;

      // Object currently under the mouse
      var touchedObject = stage;

      // Object clicked
      var selectedObject = stage;

      // Transformer of selected nodes
      var selectionTransformer = new Konva.Transformer({
        id: "Transformer",
        visible: false
      });

      nodeLayer.add(selectionTransformer);

      stage.on("mousemove", function(e) {
        // Update mouse position
        var position = stage.getPointerPosition();
        var scale = stage.scale();
        mouseX = (position.x - stage.x()) / scale.x ;
        mouseY = (position.y - stage.y()) / scale.y ;

        // Set previous target opacity to 0 if its an edge and its not selected
        if (touchedObject.id()[0] == "e" && touchedObject != selectedObject) {
          touchedObject.opacity(0);
        }

        var parent = e.target.getParent();

        if (parent == undefined) {
          // Only the stage lacks a parent
          touchedObject = stage;
        }
        else {
          var id = parent.id()[0];

          if (!isNaN(id)) {
            // Node
            touchedObject = parent;
          }
          else if (id == "T") {
            // Node transformer
            touchedObject = parent.node();
          }
          else if (e.target.id()[0] == "e") {
            // Edge
            touchedObject = e.target;

            if (touchedObject != selectedObject) {
              touchedObject.opacity(0.2);
            }
          }
          else {
            touchedObject = stage;
          }
        }

        edgeLayer.batchDraw();

        document.getElementById('text').textContent = mouseX;
      });

      stage.on("mousedown", function(e) {
        if (selectedObject != touchedObject) {
          // Make previous selected edge invisible
          if (selectedObject.id()[0] == "e") {
            selectedObject.opacity(0);
          }

          selectedObject = touchedObject;

          if (!isNaN(selectedObject.id()[0])) {
            // Left click node: Show transformer

            selectionTransformer.moveToTop();
            selectionTransformer.visible(true);
            selectionTransformer.node(selectedObject);
          }
          else if (selectedObject.id()[0] == "e") {
            // Left click edge: Show selection area

            selectionTransformer.visible(false);
            selectedObject.opacity(0.4);
          }
          else if (selectedObject.id() == "stage"){
            // Left click stage: Hide transformer

            selectionTransformer.visible(false);
          }
        }

        if (!isNaN(touchedObject.id()[0]) && window.event.metaKey) {
          // Command + Left click node: Start arrow dragging animation

          // Stop any possibly running animations
          if (newEdgeAnimation.isRunning()) {
            newEdgeAnimation.stop();
            newEdge.destroy();
          }

          // Prevent node from being dragged with arrow
          newEdgeSource = selectedObject;
          newEdgeSource.draggable(false);

          // Create arrow object
          newEdge = new Konva.Arrow({
            id: "Arrow",
            stroke: 'black',
            strokeWidth: 4
          });

          edgeLayer.add(newEdge);
          newEdge.moveToBottom();

          newEdgeAnimation.start();
        }
        stage.batchDraw();
      });

      stage.on("mouseup", function(e) {
        if (newEdgeAnimation.isRunning()) {
          newEdgeAnimation.stop();
          newEdgeSource.draggable(true);

          // Arrow dragging released over node: Create edge
          if (!isNaN(touchedObject.id()[0])) {
            new Edge({
              source: newEdgeSource,
              target: touchedObject,
              arrow: newEdge
            });
          }
          else {
            newEdge.destroy();
          }

          edgeLayer.batchDraw();
        }
      });

      // All the code for 'wheel' event was taken from Konva documentation:
      // https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html

      var scaleBy = 1.025;

      stage.on('wheel', e => {
        e.evt.preventDefault();
        var oldScale = stage.scaleX();

        var mousePointTo = {
          x: stage.getPointerPosition().x / oldScale - stage.x() / oldScale,
          y: stage.getPointerPosition().y / oldScale - stage.y() / oldScale
        };

        var newScale =
          e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
        stage.scale({ x: newScale, y: newScale });

        var newPos = {
          x:
            -(mousePointTo.x - stage.getPointerPosition().x / newScale) *
            newScale,
          y:
            -(mousePointTo.y - stage.getPointerPosition().y / newScale) *
            newScale
        };
        stage.position(newPos);
        stage.batchDraw();
      });
    </script>
  </body>
</html>
