<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.0.16/konva.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <meta charset="utf-8" />
    <title>Konva Connect Objects demo</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f0f0;
      }
    </style>
  </head>

  <body>
    <p id="text"></p>
    <div id="container"></div>
    <script>
      var width = window.innerWidth;
      var height = window.innerHeight;

      var stage = new Konva.Stage({
      id: "stage",
        container: 'container',
        width: width,
        height: height,
        draggable: true
      });

      var container = stage.container();
      container.tabIndex = 1;
      container.focus();

      var arrowLayer = new Konva.Layer({
        id: "layer-arrows"
      });
      var layer = new Konva.Layer({
        id: "layer"
      });

      stage.add(arrowLayer);
      stage.add(layer);


      var nodes = {};
      var edges = {};

      class Node extends Konva.Group {
        constructor(obj) {
          obj.draggable = true;

          // Initialize Konva.Group parameters. Be careful, additional
          // parameters of Node class could overlap those of the parent class.
          super(obj);

          this.x(this.x() - stage.x());
          this.y(this.y() - stage.y());

          // Assign node pointer to its id in nodes object
          nodes[this.id()] = this;

          // Create text object
          this.text_ = new Konva.Text({
            id: "text-".concat(this.id()),
            x: 0,
            y: 0,
            text: obj.text
          });

          this.text_.x(-this.text_.width() / 2);
          this.text_.y(-this.text_.height() / 2);

          // Create circle object
          this.circle = new Konva.Circle({
            id: "circle-".concat(this.id()),
            x: 0,
            y: 0,
            radius: 100,
            fill: "green"
          });

          this.edges = [];

          this.on("dragmove", () => {
            this.edges.forEach(edge => {
              var position = edgeTargetPosition(edge.source, edge.target);

              edge.points([edge.source.x(), edge.source.y(), position.x, position.y]);
              edge.arrow.points([edge.source.x(), edge.source.y(), position.x, position.y]);
            });

            stage.draw();
          });

          this.on("transform", () => {
            this.edges.forEach(edge => {
              var position = edgeTargetPosition(edge.source, edge.target);

              edge.points([edge.source.x(), edge.source.y(), position.x, position.y]);
              edge.arrow.points([edge.source.x(), edge.source.y(), position.x, position.y]);
            });

            stage.draw();
          });

          this.add(this.circle);
          this.add(this.text_);
          layer.add(this);

          this.zIndex(3);
          // this.circle.zIndex(4);
          // this.text.zIndex(5);

          layer.batchDraw();
        }
        radius(length) {
          if (length === undefined || length === null) {
            return this.circle.radius();
          }

          this.circle.radius(length);
        }
        text(message) {
          if (message === undefined || message === null) {
            return this.text_.text();
          }

          this.text_.text(message);
        }
        // TODO: Rename: 'connect'
        addEdge(edge) {
          this.edges.push(edge);
        }
        destroy() {
          for (var i = 0; i < this.edges.length; i++) {
            var edge = this.edges[i];
            var node = edge.source == this ? edge.target : edge.source;

            var index = node.edges.indexOf(edge);
            node.edges.splice(index, 1);

            delete edges[edge.id()];
            edge.destroy();
          }

          this.circle.destroy();
          this.text_.destroy();

          delete nodes[this.id()];

          super.destroy();
        }
        alpha(a) {
          super.alpha(a);
          this.circle.alpha(a);
        }
      };


      class Edge extends Konva.Line {
        constructor(obj) {
          var id = edgeNextID();

          obj.id = "edge-".concat(id);
          obj.strokeWidth = 18
          obj.opacity = 0;
          obj.stroke = "#69F",

          super(obj);

          this.source = obj.source;
          this.target = obj.target;

          this.source.addEdge(this);
          this.target.addEdge(this);

          var position = edgeTargetPosition(this.source, this.target);

          this.points([this.source.x(), this.source.y(), position.x, position.y]);

          this.arrow = new Konva.Arrow({
            id: "arrow-".concat(id),
            points: this.points(),
            strokeWidth: 4,
            stroke: "black"
          });

          arrowLayer.add(this.arrow);
          arrowLayer.add(this);

          this.arrow.moveToBottom();

          arrowLayer.draw();

          edges[this.id()] = this;
        }
        // TODO: remove(node1, node2)
      };

      var nodeID = 0;
      var nodeMapping = {};

      $.getJSON("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/graph", function(data) {
        data.nodes.forEach(nodeStruct => {
          var id = nodeNextID();

          nodeMapping[nodeStruct.id] = id;

          new Node({
            id: id,
            x: nodeStruct.x,
            y: nodeStruct.y,
            text: nodeStruct.text
          });
        });

        data.edges.forEach(edgeStruct => {
          new Edge({
            source: nodes[nodeMapping[edgeStruct[0]]],
            target: nodes[nodeMapping[edgeStruct[1]]]
          });
        });

        nodeID = data.nodeCount;

        stage.draw();
      });

      // async function getGraph() {
      //   let response = await fetch("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/graph");
      //
      //   if (response.ok) {
      //     let json = await response.json();
      //   } else {
      //     window.alert("HTTP-Error: " + response.status);
      //   }
      // }

      async function postGraph(data) {
        let response = await fetch("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/save", {
          method: 'POST',
          body: JSON.stringify(data)
        })
        .then(response => {
          return response.json();
        })
        .then(json => {
          if ("error" in json) {
            window.alert(json.message);
          } else {
            window.alert("Saved!");
          }
        })
        .catch(function(err) {
          window.alert("ERROR: Couldn't save work.");
          window.alert(err);
        });
      }

      function nodeNextID() {
        return (nodeID++).toString();
      }

      var edgeID = 0;
      function edgeNextID() {
        return (edgeID++).toString();
      }

      function edgeTargetPosition(source, target) {
        // Move center of plane to target
        var px = source.x() - target.x();
        var py = source.y() - target.y();

        // Convert rotation angle to radians
        var rotation = -target.rotation() * Math.PI / 180;
        var pxtmp = px;

        // Rotate plane
        px = pxtmp * Math.cos(rotation) - py * Math.sin(rotation);
        py = pxtmp * Math.sin(rotation) + py * Math.cos(rotation);

        // Rescale plane
        px /= target.scaleX();
        py /= target.scaleY();

        // Find point in which circumference and line from source to target touch
        var h = Math.sqrt(Math.pow(px, 2) + Math.pow(py, 2));

        px *= target.radius() / h,
        py *= target.radius() / h

        // Undo rescale
        px *= target.scaleX();
        py *= target.scaleY();

        // Undo rotation
        rotation = -rotation;
        pxtmp = px;

        px = pxtmp * Math.cos(rotation) - py * Math.sin(rotation);
        py = pxtmp * Math.sin(rotation) + py * Math.cos(rotation);

        // Return plane to original position
        return {
          x: px + target.x(),
          y: py + target.y()
        };
      }

      container.addEventListener("keydown", function(e) {
        if (window.event.ctrlKey && e.which == 83) {
          postGraph({
            nodeCount: nodeID,
            nodes: Object.values(nodes).map(function(node) {
              return {
                id: node.id(),
                x: node.x(),
                y: node.y(),
                text: node.text()
              };
            }),
            edges: Object.values(edges).map(function(edge) {
              return [
                edge.source.id(),
                edge.target.id()
              ];
            })
          });
        }
        if (e.which == 8 && currentSelection != stage) {
          currentSelection.destroy();
          selectionTransformer.visible(false);
          layer.draw();
        }
      });

      stage.on("dblclick", function(e) {
        if (currentTarget.id() == "stage") {
          var position = stage.getPointerPosition();

          new Node({
            id: nodeNextID(),
            x: position.x,
            y: position.y,
            text: ""
          });
        }
        else if (!isNaN(currentTarget.id()[0])) {
          // From this point until the end of the if block, code has been
          // taken from https://konvajs.org/docs/sandbox/Editable_Text.html
          var textNode = currentTarget.text_;

          textNode.hide();
          layer.batchDraw();

          // create textarea over canvas with absolute position
          // first we need to find position for textarea
          // how to find it?

          // at first lets find position of text node relative to the stage:
          var textPosition = textNode.absolutePosition();

          // then lets find position of stage container on the page:
          var stageBox = stage.container().getBoundingClientRect();

          // so position of textarea will be the sum of positions above:
          var areaPosition = {
            x: stageBox.left + textPosition.x,
            y: stageBox.top + textPosition.y
          };

          // create textarea and style it
          var textarea = document.createElement('textarea');
          document.body.appendChild(textarea);

          // apply many styles to match text on canvas as close as possible
          // remember that text rendering on canvas and on the textarea can be different
          // and sometimes it is hard to make it 100% the same. But we will try...
          textarea.value = textNode.text();
          textarea.style.position = 'absolute';
          textarea.style.top = areaPosition.y + 'px';
          textarea.style.left = areaPosition.x + 'px';
          textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
          textarea.style.height =
            textNode.height() - textNode.padding() * 2 + 5 + 'px';
          textarea.style.fontSize = textNode.fontSize() + 'px';
          textarea.style.border = 'none';
          textarea.style.padding = '0px';
          textarea.style.margin = '0px';
          textarea.style.overflow = 'hidden';
          textarea.style.background = 'none';
          textarea.style.outline = 'none';
          textarea.style.resize = 'none';
          textarea.style.lineHeight = textNode.lineHeight();
          textarea.style.fontFamily = textNode.fontFamily();
          textarea.style.transformOrigin = 'left top';
          textarea.style.textAlign = textNode.align();
          textarea.style.color = textNode.fill();
          rotation = textNode.rotation();
          var transform = '';
          if (rotation) {
            transform += 'rotateZ(' + rotation + 'deg)';
          }

          var px = 0;
          // also we need to slightly move textarea on firefox
          // because it jumps a bit
          var isFirefox =
            navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          if (isFirefox) {
            px += 2 + Math.round(textNode.fontSize() / 20);
          }
          transform += 'translateY(-' + px + 'px)';

          textarea.style.transform = transform;

          // reset height
          textarea.style.height = 'auto';
          // after browsers resized it we can set actual value
          textarea.style.height = textarea.scrollHeight + 3 + 'px';

          textarea.focus();

          function removeTextarea() {
            textarea.parentNode.removeChild(textarea);
            window.removeEventListener('click', handleOutsideClick);
            textNode.show();
            layer.draw();
          }

          function setTextareaWidth(newWidth) {
            if (!newWidth) {
              // set width for placeholder
              newWidth = textNode.placeholder.length * textNode.fontSize();
            }
            // some extra fixes on different browsers
            var isSafari = /^((?!chrome|android).)*safari/i.test(
              navigator.userAgent
            );
            var isFirefox =
              navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isSafari || isFirefox) {
              newWidth = Math.ceil(newWidth);
            }

            var isEdge =
              document.documentMode || /Edge/.test(navigator.userAgent);
            if (isEdge) {
              newWidth += 1;
            }
            textarea.style.width = newWidth + 'px';
          }

          textarea.addEventListener('keydown', function(e) {
            // hide on enter
            // but don't hide on shift + enter
            if (e.keyCode === 13 && !e.shiftKey) {
              textNode.text(textarea.value);
              removeTextarea();
            }
            // on esc do not set value back to node
            if (e.keyCode === 27) {
              removeTextarea();
            }
          });

          textarea.addEventListener('keydown', function(e) {
            scale = textNode.getAbsoluteScale().x;
            setTextareaWidth(textNode.width() * scale);
            textarea.style.height = 'auto';
            textarea.style.height =
              textarea.scrollHeight + textNode.fontSize() + 'px';
          });

          function handleOutsideClick(e) {
            if (e.target !== textarea) {
              textNode.text(textarea.value);
              removeTextarea();
            }
          }
          setTimeout(() => {
            window.addEventListener('click', handleOutsideClick);
          });
        }
      });


      var mouseX, mouseY;
      var newEdgeAnimation = new Konva.Animation(function(frame){}),
          newEdge = null,
          newEdgeSource;
      var currentTarget = stage,
          previousTarget = stage;
      var currentSelection = stage;
      var selectionTransformer = new Konva.Transformer({
        id: "Transformer",
        visible: false
        // zIndex: 6
      });

      layer.add(selectionTransformer);
      // selectionTransformer.moveToTop();

      stage.on("mousemove", function(e) {
        var position = stage.getPointerPosition();
        mouseX = position.x - stage.x();
        mouseY = position.y - stage.y();

        previousTarget = currentTarget;

        var parent = e.target.getParent();

        if (parent == undefined) {
          currentTarget = stage;
        }
        else {
          var id = parent.id()[0];
          if (!isNaN(id)) {
            currentTarget = parent;
          }
          else if (id == "T") {
            currentTarget = parent.node();
          }
          else if (e.target.id()[0] == "e") {
            currentTarget = e.target;
            currentTarget.opacity(0.2);
          }
          else {
            currentTarget = stage;
          }
        }

        if (previousTarget != currentTarget && previousTarget.id()[0] == "e") {
          previousTarget.opacity(0);
        }
        arrowLayer.batchDraw();

        document.getElementById('text').textContent = currentTarget.id();
      });

      stage.on("mousedown", function(e) {
        if (currentSelection != currentTarget) {
          currentSelection = currentTarget;

          // If current selection is a node or its transformer
          if (!isNaN(currentSelection.id()[0])) {
            selectionTransformer.moveToTop();
            selectionTransformer.visible(true);
            selectionTransformer.node(currentSelection);
          }
          else if (currentSelection.id() == "stage"){
            selectionTransformer.visible(false);
          }
        }

        if (!isNaN(currentTarget.id()[0]) && window.event.metaKey) {
          if (newEdgeAnimation.isRunning()) {
            newEdgeAnimation.stop();
            newEdge.destroy();
          }

          newEdgeSource = currentSelection;

          newEdge = new Konva.Arrow({
            id: "Arrow",
            stroke: 'black',
            strokeWidth: 4
          });

          newEdgeAnimation = new Konva.Animation(function (frame) {
            var targetX, targetY;

            if (!isNaN(currentTarget.id()[0]) && currentTarget != newEdgeSource) {
              var position = edgeTargetPosition(newEdgeSource, currentTarget);

              targetX = position.x;
              targetY = position.y;
            } else {
              targetX = mouseX;
              targetY = mouseY;
            }

            newEdge.points([newEdgeSource.x(), newEdgeSource.y(), targetX, targetY]);
          }, layer);

          layer.add(newEdge);
          newEdge.moveToBottom();
          newEdge.zIndex(1);
          newEdgeSource.draggable(false);

          newEdgeAnimation.start();
        }
      });

      stage.on("mouseup", function(e) {
        if (newEdgeAnimation.isRunning()) {
          newEdgeAnimation.stop();
          newEdgeSource.draggable(true);

          if (!isNaN(currentTarget.id()[0])) {
            new Edge({
              source: newEdgeSource,
              target: currentTarget
            });
          }

          newEdge.destroy();

          layer.batchDraw();
        }
      });

      // All the code for 'wheel' event was taken from Konva demos, code taken
      // from: https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html

      var scaleBy = 1.025;

      stage.on('wheel', e => {
        e.evt.preventDefault();
        var oldScale = stage.scaleX();

        var mousePointTo = {
          x: stage.getPointerPosition().x / oldScale - stage.x() / oldScale,
          y: stage.getPointerPosition().y / oldScale - stage.y() / oldScale
        };

        var newScale =
          e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
        stage.scale({ x: newScale, y: newScale });

        var newPos = {
          x:
            -(mousePointTo.x - stage.getPointerPosition().x / newScale) *
            newScale,
          y:
            -(mousePointTo.y - stage.getPointerPosition().y / newScale) *
            newScale
        };
        stage.position(newPos);
        stage.batchDraw();
      });
      // var text = new Konva.Text({
      //   text: 'Hola',
      //   x: 100,
      //   y: 100
      // })

      // layer.add(text);

      // var tr = new Konva.Transformer({
      //   node: circle,
      //   enabledAnchors: ['top-center', 'bottom-center', 'middle-left', 'middle-right'],
      //   visible: false,
      //   // set minimum width of text
      //   boundBoxFunc: function(oldBox, newBox) {
      //     newBox.width = Math.max(30, newBox.width);
      //     newBox.height = Math.max(30, newBox.height);
      //     return newBox;
      //   }
      // });

      // layer.add(tr);

      // circle.on('dragmove', function() {
      //   text.x(circle.x());
      //   text.y(circle.y());
      // });

      // circle.on('click', function() {
      //   tr.visible(true);
      // });

      // circle.on('transform', function() {
      //   circle.setAttrs({
      //     width: circle.width() * circle.scaleX(),
      //     height: circle.height() * circle.scaleY(),
      //     scaleX: 1,
      //     scaleY: 1
      //   });

      //   text.x(circle.x());
      //   text.y(circle.y());
      //   text.rotation(circle.rotation());
      // });

      // layer.batchDraw();
    </script>
  </body>
</html>
