<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.0.16/konva.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <meta charset="utf-8" />
    <title>Konva Connect Objects demo</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f0f0;
      }
    </style>
  </head>

  <body>
    <p id="text"></p>
    <div id="container"></div>
    <script>
      var width = window.innerWidth;
      var height = window.innerHeight;

      var stage = new Konva.Stage({
      id: "stage",
        container: 'container',
        width: width,
        height: height,
        draggable: true
      });

      // Let stage capture key events
      var container = stage.container();
      container.tabIndex = 1;
      container.focus();

      // Layer for arrows, drawn below layer of nodes
      var arrowLayer = new Konva.Layer({
        id: "Layer-arrows"
      });
      var nodeLayer = new Konva.Layer({
        id: "Layer-nodes"
      });

      stage.add(arrowLayer);
      stage.add(nodeLayer);


      // Objects that map ids of nodes and edges to their objects
      var nodes = {};
      // TODO: Check if edges is necessary, could be deleted
      var edges = {};

      class Node extends Konva.Group {
        constructor(obj) {
          /**
            Arguments:
            obj -- Initialization object for parent class, circle and text.
          **/

          var id = nodeNextID();

          // Set constant parameters
          obj.id = id;
          obj.draggable = true;
          obj.x = obj.x - stage.x();
          obj.y = obj.y - stage.y();

          super(obj);

          // Create text object
          this.text_ = new Konva.Text({
            id: "text-".concat(this.id()),
            x: 0,
            y: 0,
            text: obj.text
          });

          // Put text to middle of circle
          this.text_.x(-this.text_.width() / 2);
          this.text_.y(-this.text_.height() / 2);

          // Create circle object
          this.circle = new Konva.Circle({
            id: "circle-".concat(this.id()),
            x: 0,
            y: 0,
            radius: 100,
            fill: "green"
          });

          this.edges = [];

          // Re-draw edges when dragged
          this.on("dragmove", () => {
            this.edges.forEach(edge => {
              var position = edgeTargetPosition(edge.source, edge.target);

              edge.points([edge.source.x(), edge.source.y(), position.x, position.y]);
              edge.arrow.points([edge.source.x(), edge.source.y(), position.x, position.y]);
            });

            arrowLayer.draw();
          });

          // Re-draw edges when transformed
          this.on("transform", () => {
            this.edges.forEach(edge => {
              var position = edgeTargetPosition(edge.source, edge.target);

              edge.points([edge.source.x(), edge.source.y(), position.x, position.y]);
              edge.arrow.points([edge.source.x(), edge.source.y(), position.x, position.y]);
            });

            arrowLayer.draw();
          });

          // Add circle and text to node, and node to the node layer.
          this.add(this.circle);
          this.add(this.text_);
          nodeLayer.add(this);

          nodeLayer.batchDraw();

          // Assign node pointer to its id in nodes object
          nodes[this.id()] = this;
        }
        radius(radius) {
          /**
            Getter and Setter of node radius.

            Arguments:
            radius -- New radius to set. If undefined, method is getter.

            Returns:
            If radius is undefined, returns radius of circle. If not, returns
            Node object with updated radius.
          **/
          if (radius === undefined || radius === null) {
            return this.circle.radius();
          }
          else {
            this.circle.radius(radius);

            return this;
          }
        }
        text(text) {
          /**
            Getter and Setter of node text.

            Arguments:
            text -- New text to set. If undefined, method is getter.

            Returns:
            If text is undefined, returns text of node. If not, returns
            Node object with updated text.
          **/

          if (text === undefined || text === null) {
            return this.text_.text();
          }
          else {
            this.text_,text(text);

            return this;
          }
        }
        connect(edge) {
          /**
            Connects node with an edge.

            Arguments:
            edge -- Edge object to connect with node.
          **/

          this.edges.push(edge);
        }
        destroy() {
          /**
            Destroy node, circle, text and neighbor edges.
          **/

          // Destroy edges
          this.edges.forEach(edge => {
            edge.destroy(edge.source == this ? edge.target : edge.source);
          });

          // Remove node from object of nodes
          delete nodes[this.id()];

          // Destroy remaining objects
          this.circle.destroy();
          this.text_.destroy();

          super.destroy();
        }
        alpha(a) {
          super.alpha(a);
          this.circle.alpha(a);
        }
      };


      class Edge extends Konva.Line {
        // TODO: Accept arrow attribute
        constructor(obj) {
          /**
            Arguments:
            obj -- Initialization object for parent class and arrow.
          **/

          var id = edgeNextID();

          // Set constant parameters

          obj.id = "edge-".concat(id);
          obj.strokeWidth = 18
          obj.opacity = 0;
          obj.stroke = "#69F",

          super(obj);

          // Define and connect source and target nodes
          this.source = obj.source;
          this.target = obj.target;

          this.source.connect(this);
          this.target.connect(this);

          // Find tagrget position for arrow
          var position = edgeTargetPosition(this.source, this.target);

          this.points([this.source.x(), this.source.y(), position.x, position.y]);

          // Create arrow object
          this.arrow = new Konva.Arrow({
            id: "arrow-".concat(id),
            points: this.points(),
            strokeWidth: 4,
            stroke: "black"
          });

          // Add edge and arrow objects to arrow layer
          arrowLayer.add(this.arrow);
          arrowLayer.add(this);

          // Hide arrow behind touch area
          this.arrow.moveToBottom();

          arrowLayer.draw();

          // Assign edge pointer to its id in nodes object
          edges[this.id()] = this;
        }
        destroy(target) {
          /**
            Destroy node, circle, text and neighbor edges.

            Arguments:
            target -- Node from which edge must be deleted. If undefined,
                      destroy from both nodes.
          **/

          var index;

          // Remove edge from edge lists of nodes
          if (target != this.target) {
            index = this.source.edges.indexOf(this);
            this.source.edges.splice(index, 1);
          }
          if (target != this.source) {
            index = this.target.edges.indexOf(this);
            this.target.edges.splice(index, 1);
          }

          // Remove edge from object of edges
          delete edges[this.id()];

          // Destroy objects
          this.arrow.destroy();

          super.destroy();
        }
      };

      // Mapping from node id's in serve to assigned id's in session
      var nodeMapping = {};

      async function getGraph() {
        /**
          Get graph nodes and edges.
        **/

        let response = await fetch("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/graph");

        if (response.ok) {
          // Get json if valid response
          let data = await response.json();

          // Map each node in server with new id of session
          data.nodes.forEach(nodeStruct => {
            var node = new Node({
              x: nodeStruct.x,
              y: nodeStruct.y,
              text: nodeStruct.text
            });

            nodeMapping[nodeStruct.id] = node.id();
          });

          // Create new edge with mapped ids
          data.edges.forEach(edgeStruct => {
            new Edge({
              source: nodes[nodeMapping[edgeStruct[0]]],
              target: nodes[nodeMapping[edgeStruct[1]]]
            });
          });

          stage.draw();
        } else {
          // Error message
          window.alert("HTTP-Error: " + response.status);
        }
      }

      async function postGraph(data) {
        /**
          Post updated graph nodes and edges.

          Arguments:
          data -- Object that holds nodes, edges and nodeCount keys.
            nodes -- List of objects of attributes id, x, y and text.
            edges -- List of lists, pirs of source and target id's respectively.
            nodeCount -- Next id that won't conflict with previous id's.
        **/

        let response = await fetch("https://www.wolframcloud.com/obj/cesars/graphofideas/api/v1/save", {
          method: 'POST',
          body: JSON.stringify(data)
        })
        .then(response => {
          return response.json();
        })
        .then(json => {
          if ("error" in json) {
            // Invalid data object format
            window.alert(json.message);
          }
          else {
            window.alert("Saved!");
          }
        })
        .catch(function(err) {
          // Unable to fetch
          window.alert("ERROR: Couldn't save work.");
          window.alert(err);
        });
      }

      getGraph();

      // TODO: If multithreading is available, this function should be atomic
      var nodeID = 0;
      function nodeNextID() {
        /**
          Get id of next node.
        **/

        return (nodeID++).toString();
      }

      // TODO: Check if edges need ids. If not, delete this function
      var edgeID = 0;
      function edgeNextID() {
        /**
          Get id of next edge.
        **/

        return (edgeID++).toString();
      }

      function edgeTargetPosition(source, target) {
        /**
          Find point of arrow head given the source and target nodes.

          Arguments:
          source -- Node from which the arrow is drawn.
          target -- Node where the arrow points.

          Returns:
          -- Object of attributes x and y.
            x -- Number of x coordinate of arrow head.
            y -- Number of y coordinate of arrow head.
        **/

        // Move center of plane to target
        var px = source.x() - target.x();
        var py = source.y() - target.y();

        // Convert rotation angle to radians
        var rotation = -target.rotation() * Math.PI / 180;
        var pxtmp = px;

        // Rotate plane
        px = pxtmp * Math.cos(rotation) - py * Math.sin(rotation);
        py = pxtmp * Math.sin(rotation) + py * Math.cos(rotation);

        // Rescale plane
        px /= target.scaleX();
        py /= target.scaleY();

        // Find point in which circumference and line from source to target touch
        var h = Math.sqrt(Math.pow(px, 2) + Math.pow(py, 2));

        px *= target.radius() / h,
        py *= target.radius() / h

        // Undo rescale
        px *= target.scaleX();
        py *= target.scaleY();

        // Undo rotation
        rotation = -rotation;
        pxtmp = px;

        px = pxtmp * Math.cos(rotation) - py * Math.sin(rotation);
        py = pxtmp * Math.sin(rotation) + py * Math.cos(rotation);

        // Return plane to original position
        return {
          x: px + target.x(),
          y: py + target.y()
        };
      }

      container.addEventListener("keydown", function(e) {
        // Ctrl + S: Save graph
        if (window.event.ctrlKey && e.which == 83) {
          postGraph({
            nodeCount: nodeID,
            nodes: Object.values(nodes).map(function(node) {
              return {
                id: node.id(),
                x: node.x(),
                y: node.y(),
                text: node.text()
              };
            }),
            edges: Object.values(edges).map(function(edge) {
              return [
                edge.source.id(),
                edge.target.id()
              ];
            })
          });
        }
        // Return: Delete selected object
        if (e.which == 8 && currentSelection != stage) {
          currentSelection.destroy();
          selectionTransformer.visible(false);
          stage.draw();
        }
      });

      stage.on("dblclick", function(e) {
        // Double click stage: Create node
        if (currentTarget.id() == "stage") {
          var position = stage.getPointerPosition();

          new Node({
            x: position.x,
            y: position.y,
            text: ""
          });
        }
        // Double click node: Text edition
        else if (!isNaN(currentTarget.id()[0])) {
          // From this point until the end of the if block, code has been
          // taken from https://konvajs.org/docs/sandbox/Editable_Text.html
          var textNode = currentTarget.text_;

          textNode.hide();
          nodeLayer.batchDraw();

          // create textarea over canvas with absolute position
          // first we need to find position for textarea
          // how to find it?

          // at first lets find position of text node relative to the stage:
          var textPosition = textNode.absolutePosition();

          // then lets find position of stage container on the page:
          var stageBox = stage.container().getBoundingClientRect();

          // so position of textarea will be the sum of positions above:
          var areaPosition = {
            x: stageBox.left + textPosition.x,
            y: stageBox.top + textPosition.y
          };

          // create textarea and style it
          var textarea = document.createElement('textarea');
          document.body.appendChild(textarea);

          // apply many styles to match text on canvas as close as possible
          // remember that text rendering on canvas and on the textarea can be different
          // and sometimes it is hard to make it 100% the same. But we will try...
          textarea.value = textNode.text();
          textarea.style.position = 'absolute';
          textarea.style.top = areaPosition.y + 'px';
          textarea.style.left = areaPosition.x + 'px';
          textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
          textarea.style.height =
            textNode.height() - textNode.padding() * 2 + 5 + 'px';
          textarea.style.fontSize = textNode.fontSize() + 'px';
          textarea.style.border = 'none';
          textarea.style.padding = '0px';
          textarea.style.margin = '0px';
          textarea.style.overflow = 'hidden';
          textarea.style.background = 'none';
          textarea.style.outline = 'none';
          textarea.style.resize = 'none';
          textarea.style.lineHeight = textNode.lineHeight();
          textarea.style.fontFamily = textNode.fontFamily();
          textarea.style.transformOrigin = 'left top';
          textarea.style.textAlign = textNode.align();
          textarea.style.color = textNode.fill();
          rotation = textNode.rotation();
          var transform = '';
          if (rotation) {
            transform += 'rotateZ(' + rotation + 'deg)';
          }

          var px = 0;
          // also we need to slightly move textarea on firefox
          // because it jumps a bit
          var isFirefox =
            navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          if (isFirefox) {
            px += 2 + Math.round(textNode.fontSize() / 20);
          }
          transform += 'translateY(-' + px + 'px)';

          textarea.style.transform = transform;

          // reset height
          textarea.style.height = 'auto';
          // after browsers resized it we can set actual value
          textarea.style.height = textarea.scrollHeight + 3 + 'px';

          textarea.focus();

          function removeTextarea() {
            textarea.parentNode.removeChild(textarea);
            window.removeEventListener('click', handleOutsideClick);
            textNode.show();
            nodeLayer.draw();
          }

          function setTextareaWidth(newWidth) {
            if (!newWidth) {
              // set width for placeholder
              newWidth = textNode.placeholder.length * textNode.fontSize();
            }
            // some extra fixes on different browsers
            var isSafari = /^((?!chrome|android).)*safari/i.test(
              navigator.userAgent
            );
            var isFirefox =
              navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isSafari || isFirefox) {
              newWidth = Math.ceil(newWidth);
            }

            var isEdge =
              document.documentMode || /Edge/.test(navigator.userAgent);
            if (isEdge) {
              newWidth += 1;
            }
            textarea.style.width = newWidth + 'px';
          }

          textarea.addEventListener('keydown', function(e) {
            // hide on enter
            // but don't hide on shift + enter
            if (e.keyCode === 13 && !e.shiftKey) {
              textNode.text(textarea.value);
              removeTextarea();
            }
            // on esc do not set value back to node
            if (e.keyCode === 27) {
              removeTextarea();
            }
          });

          textarea.addEventListener('keydown', function(e) {
            scale = textNode.getAbsoluteScale().x;
            setTextareaWidth(textNode.width() * scale);
            textarea.style.height = 'auto';
            textarea.style.height =
              textarea.scrollHeight + textNode.fontSize() + 'px';
          });

          function handleOutsideClick(e) {
            if (e.target !== textarea) {
              textNode.text(textarea.value);
              removeTextarea();
            }
          }
          setTimeout(() => {
            window.addEventListener('click', handleOutsideClick);
          });
        }
      });


      // Mouse position
      var mouseX, mouseY;

      // Dragged new edge animation
      var newEdgeAnimation = new Konva.Animation(function(frame){}),
          newEdge = null,
          newEdgeSource;

      // TODO: Rename to mouseObject
      // Object currently under the mouse
      var currentTarget = stage;

      // TODO: Rename to selectedObject
      // Object clicked
      var currentSelection = stage;

      // Transformer of selected nodes
      var selectionTransformer = new Konva.Transformer({
        id: "Transformer",
        visible: false
      });

      nodeLayer.add(selectionTransformer);

      stage.on("mousemove", function(e) {
        // Update mouse position
        var position = stage.getPointerPosition();
        mouseX = position.x - stage.x();
        mouseY = position.y - stage.y();

        // Set previous target opacity to 0 if its an edge and its not selected
        if (currentTarget.id()[0] == "e" && currentTarget != currentSelection) {
          currentTarget.opacity(0);
        }

        var parent = e.target.getParent();

        if (parent == undefined) {
          // Only the stage lacks a parent
          currentTarget = stage;
        }
        else {
          var id = parent.id()[0];

          if (!isNaN(id)) {
            // Node
            currentTarget = parent;
          }
          else if (id == "T") {
            // Node transformer
            currentTarget = parent.node();
          }
          else if (e.target.id()[0] == "e") {
            // Edge
            currentTarget = e.target;

            if (currentTarget != currentSelection) {
              currentTarget.opacity(0.2);
            }
          }
          else {
            currentTarget = stage;
          }
        }

        arrowLayer.batchDraw();

        document.getElementById('text').textContent = currentTarget.id();
      });

      stage.on("mousedown", function(e) {
        if (currentSelection != currentTarget) {
          // Make previous selected edge invisible
          if (currentSelection.id()[0] == "e") {
            currentSelection.opacity(0);
          }

          currentSelection = currentTarget;

          if (!isNaN(currentSelection.id()[0])) {
            // Left click node: Show transformer

            selectionTransformer.moveToTop();
            selectionTransformer.visible(true);
            selectionTransformer.node(currentSelection);
          }
          else if (currentSelection.id()[0] == "e") {
            // Left click edge: Show selection area

            selectionTransformer.visible(false);
            currentSelection.opacity(0.4);
          }
          else if (currentSelection.id() == "stage"){
            // Left click stage: Hide transformer

            selectionTransformer.visible(false);
          }
        }

        if (!isNaN(currentTarget.id()[0]) && window.event.metaKey) {
          // Command + Left click node: Start arrow dragging animation

          // Stop any possibly running animations
          if (newEdgeAnimation.isRunning()) {
            newEdgeAnimation.stop();
            newEdge.destroy();
          }

          // Prevent node from being dragged with arrow
          newEdgeSource = currentSelection;
          newEdgeSource.draggable(false);

          // Create arrow object
          newEdge = new Konva.Arrow({
            id: "Arrow",
            stroke: 'black',
            strokeWidth: 4
          });

          // Create animation that sets arrow position to mouse position
          // OPTIMIZE: Use only one animation
          newEdgeAnimation = new Konva.Animation(function (frame) {
            var targetX, targetY;

            if (!isNaN(currentTarget.id()[0]) && currentTarget != newEdgeSource) {
              // Assign arrow head position to node border

              var position = edgeTargetPosition(newEdgeSource, currentTarget);

              targetX = position.x;
              targetY = position.y;
            } else {
              // Assign arrow head position to mouse

              targetX = mouseX;
              targetY = mouseY;
            }

            newEdge.points([newEdgeSource.x(), newEdgeSource.y(), targetX, targetY]);
          }, nodeLayer);

          nodeLayer.add(newEdge);
          newEdge.moveToBottom();

          newEdgeAnimation.start();
        }
      });

      stage.on("mouseup", function(e) {
        if (newEdgeAnimation.isRunning()) {
          newEdgeAnimation.stop();
          newEdgeSource.draggable(true);

          // Arrow dragging released over node: Create edge
          if (!isNaN(currentTarget.id()[0])) {
            new Edge({
              source: newEdgeSource,
              target: currentTarget
            });
          }

          newEdge.destroy();

          nodeLayer.batchDraw();
        }
      });

      // All the code for 'wheel' event was taken from Konva demos, code taken
      // from: https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html

      var scaleBy = 1.025;

      stage.on('wheel', e => {
        e.evt.preventDefault();
        var oldScale = stage.scaleX();

        var mousePointTo = {
          x: stage.getPointerPosition().x / oldScale - stage.x() / oldScale,
          y: stage.getPointerPosition().y / oldScale - stage.y() / oldScale
        };

        var newScale =
          e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
        stage.scale({ x: newScale, y: newScale });

        var newPos = {
          x:
            -(mousePointTo.x - stage.getPointerPosition().x / newScale) *
            newScale,
          y:
            -(mousePointTo.y - stage.getPointerPosition().y / newScale) *
            newScale
        };
        stage.position(newPos);
        stage.batchDraw();
      });
    </script>
  </body>
</html>
